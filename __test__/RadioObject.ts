import { expect, vi } from "vitest";
import type {
  ClickableView,
  RadioButtonManager,
  RadioButtonMesh,
  RadioButtonSprite,
} from "../src/index.js";
import { clickButton } from "./MouseControl.js";

/**
 * Generates sample button values for radio button testing
 *
 * @returns Array of diverse value types for comprehensive radio button testing
 *
 * @description
 * Returns a predefined array of diverse value types to test radio button
 * value handling across different data types including strings, numbers,
 * objects, and undefined values.
 */
export function getButtonValues(): unknown[] {
  return ["button01", 2, { value: "button03" }, undefined, undefined];
}

/**
 * Tests radio button manager initialization with multiple buttons
 *
 * @param manager - RadioButtonManager instance to test
 * @param generator - Function that creates radio button instances from values
 *
 * @description
 * Validates that a RadioButtonManager can properly store and manage
 * radio buttons generated by the provided generator function. Verifies
 * that button values are correctly preserved after addition to the manager.
 */
export function testInitManager(
  manager: RadioButtonManager,
  generator: (value: unknown) => RadioButtonMesh | RadioButtonSprite,
) {
  const values = getButtonValues();
  for (const value of values) {
    manager.addButton(generator(value));
  }
  expect(
    manager.interactionHandlers[2].value,
    `Manager should store button value correctly: expected ${JSON.stringify(values[2])} at index 2`,
  ).toBe(values[2]);
}

/**
 * Tests exclusive selection behavior and event emission
 *
 * @param manager - RadioButtonManager instance with pre-populated radio buttons
 *
 * @description
 * Validates the core radio button functionality including exclusive selection,
 * frozen state management, and proper event emission. Tests both initial
 * selection and re-selection scenarios to ensure correct behavior.
 */
export function testRadioSelection(manager: RadioButtonManager) {
  const values = getButtonValues();

  const spySelect = vi.fn(() => {});
  manager.on("select", spySelect);

  const index = 0;
  const handler = manager.interactionHandlers[index];

  expect(
    handler.isFrozen,
    "Handler should not be frozen before selection",
  ).toBe(false);
  manager.select(handler);
  expect(
    manager.selected?.value,
    `Selected value should be ${JSON.stringify(values[index])}`,
  ).toEqual(values[index]);
  expect(
    spySelect,
    "Select event should be emitted when button is selected",
  ).toBeCalled();

  expect(
    handler.isFrozen,
    "Handler should be frozen after selection for exclusive behavior",
  ).toBe(true);

  spySelect.mockClear();
  manager.select(handler);
  expect(
    spySelect,
    "Select event should not be emitted when selecting already selected button",
  ).not.toBeCalled();
  expect(
    handler.isFrozen,
    "Handler should remain frozen after re-selection attempt",
  ).toBe(true);
}

/**
 * Tests radio button selection via mouse interactions
 *
 * @param manager - RadioButtonManager instance with at least 3 radio buttons
 *
 * @description
 * Validates mouse-driven radio button selection behavior including state
 * transitions and frozen state management. Tests that mouse clicks properly
 * trigger selection changes and that already selected buttons ignore
 * subsequent clicks (frozen behavior).
 */
export function testRadioSelectionWithMouse(manager: RadioButtonManager) {
  manager.select(manager.interactionHandlers[0]);

  const index = 2;
  const handler = manager.interactionHandlers[index];

  expect(
    handler.isFrozen,
    `Handler at index ${index} should not be frozen before mouse selection`,
  ).toBe(false);
  clickButton(handler.view);
  expect(
    handler.isFrozen,
    `Handler at index ${index} should be frozen after mouse selection`,
  ).toBe(true);
  expect(
    manager.selected?.value,
    `Manager selected value should match handler value: ${JSON.stringify(handler.value)}`,
  ).toEqual(handler.value);

  onClickSecondTime(handler.view);
}

/**
 * Tests that frozen radio buttons ignore subsequent click events
 *
 * @param button - Selected radio button to test frozen behavior
 *
 * @description
 * Internal helper function that validates frozen radio button behavior
 * by attempting to click an already selected radio button and verifying
 * that no click or select events are emitted.
 */
const onClickSecondTime = <T>(button: ClickableView<T>) => {
  const spyClick = vi.fn(() => {});
  const spySelect = vi.fn(() => {});

  button.interactionHandler.on("click", spyClick);
  button.interactionHandler.on("select", spySelect);

  clickButton(button);

  expect(
    spyClick,
    "Click event should not be emitted when clicking frozen radio button",
  ).not.toBeCalled();
  expect(
    spySelect,
    "Select event should not be emitted when clicking already selected radio button",
  ).not.toBeCalled();
};
