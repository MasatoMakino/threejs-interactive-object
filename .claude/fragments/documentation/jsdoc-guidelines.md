# LLM-First JSDoc Documentation Guidelines

このドキュメントは、LLMエージェントが効果的にコードを理解・改修できるよう、**意思決定の動機**と**責任範囲**を中心としたJSDocベストプラクティスを定めます。プロジェクトや技術スタックに依存しない汎用的なガイドラインとして設計されており、あらゆるJavaScript/TypeScriptプロジェクトで適用可能です。

## ドキュメントの目的

**従来のドキュメンテーション**: API仕様や使用方法の説明が中心  
**LLMファーストドキュメンテーション**: なぜその設計を選択したかの背景と意図を重視

LLMは構文やパターンは理解できますが、人間の思考プロセスや意思決定の文脈は推測できません。このガイドラインは、その「見えない部分」を明文化することで、LLMがより適切なコード理解・生成を行えるよう支援します。

## アプローチの利点と欠点

### 利点

**仕様の近接性**:
- 仕様がコードと同じファイルに記述されるため、LLMのコンテキストに収まりやすい
- コード変更時に仕様も同時に目に入るため、更新忘れが起きにくい
- 分散した仕様書を探索する精度の問題を回避

**同期の確実性**:
- コードと仕様が物理的に近い位置にあるため、変更の同期が容易
- 外部仕様書との不整合リスクを大幅に削減
- Pull Request時にコードと仕様を一括レビュー可能

**LLM処理効率**:
- 仕様とコードが同一コンテキスト内に存在するため検索不要
- ファイル間の関連性推測が不要
- 1回の読み込みで設計意図とコードの両方を理解可能

### 欠点

**コードの肥大化**:
- JSDocコメントによりファイルサイズが大幅に増加
- 実装コードの視認性が低下
- スクロール量の増加により全体把握が困難

**保守負荷の増加**:
- コメントの更新コストが発生
- 詳細な記述ほど変更時の修正箇所が増加
- 実装変更時の文書更新が必須

**可読性の悪化**:
- 人間にとってコードの流れが追いにくくなる
- 本質的でない情報が画面を占有
- 新規参加者の学習曲線が急峻化

### LLM処理能力による欠点の踏み倒し

このアプローチは以下の前提に基づいています：

**LLMの処理能力仮定**:
- 大量のテキストを高速で処理可能
- コードとコメントを区別して理解可能
- 肥大化したファイルでも本質的な情報を抽出可能

**従来の問題の解決**:
```
従来: 仕様書分離 → 検索精度低下・同期困難
新規: JSDoc集約 → 肥大化・可読性低下 → LLMで踏み倒し
```

**トレードオフの選択**:
- 人間の可読性 < LLM効率性 + 仕様同期確実性
- 短期的な開発効率 < 長期的な保守性
- ファイルサイズ < コンテキスト一貫性

### 適用判断基準

**このアプローチが有効な場合**:
- LLMエージェントが開発チームの主要メンバー
- 長期運用されるプロジェクト
- API仕様の変更が頻繁
- 複雑なビジネスロジックを含む

**従来手法が適している場合**:
- 人間中心の開発チーム
- 短期プロジェクト
- 仕様が安定している
- シンプルな処理が中心

## 基本理念

### LLMエージェント配慮型ドキュメンテーション

ソースコードから推測困難な以下の情報を最優先で記録：

1. **意思決定の動機** - なぜその実装を選択したか
2. **責任範囲** - 何を処理し、何を処理しないか
3. **設計制約** - 技術的・感覚的制限要因
4. **アーキテクチャ意図** - 将来の変更における考慮事項
5. **トレードオフ** - 何を犠牲にして何を優先したか
6. **前提条件** - 実装が依存する環境・状況

### LLMの理解を助ける原則

**明示的記述の重要性**:
- 暗黙の前提は必ず明文化
- 「常識」や「当然」は記述対象
- 人間には自明でもLLMには不明な情報を重視

**コンテキスト保存**:
- 実装時の状況・制約を記録
- 代替案検討の痕跡を残す
- 将来の判断材料となる情報を含む

## JSDoc構造の最適化

### 要約行（最初の一行）の重要性

**目的**: IDEのポップアップウィンドウでの表示に最適化された簡潔な機能説明

**情報量の目安**: 
- 関数名やクラス名から受け取れる情報よりも大きく
- 一文で収まる範囲

**記述原則**:
- 関数名では伝わらない「何を」「どのように」を補完
- 専門的な処理方法や制約があれば簡潔に言及
- 詳細な契約や設計意図は@descriptionや他のタグで説明

### 良い要約行の例

**関数名の情報を適切に補完**:
```typescript
/**
 * 有効なアイテムのみを抽出したフィルタリング済み配列を返します
 */
function filterItems(items: Item[]): Item[] {}

/**
 * ラジオボタン間の排他的選択動作を管理します
 */
class RadioButtonManager<T> {}

/**
 * 指定されたパスのファイルを非同期で読み込みます
 */
async function loadFile(path: string): Promise<Buffer> {}
```

**情報量が適切でない例**:
```typescript
// ❌ 関数名と同じ情報量（不十分）
/**
 * アイテムをフィルタリングします
 */
function filterItems(items: Item[]): Item[] {}

// ❌ 一文を超える詳細情報（過剰）
/**
 * アイテム配列を受け取り、各要素の有効性を検証し、条件に合致する要素のみを含む新しい配列を生成して返します。元の配列は変更されません。
 */
function filterItems(items: Item[]): Item[] {}

// ✅ 適切な情報量
/**
 * 有効なアイテムのみを抽出したフィルタリング済み配列を返します
 */
function filterItems(items: Item[]): Item[] {}
```

### 比較表現の禁止原則

**基本ルール**: 比較対象が明確でない比較表現は禁止

**禁止される表現例**:
- more efficient, faster, better（何と比較して？）
- improved, enhanced, optimized（何からの改善？）
- advanced, superior, simplified（何に対して？）

**❌ 悪い例**:
```typescript
/**
 * より高速なソートアルゴリズムを実装します
 */
function quickSort(items: Item[]): Item[] {}

/**
 * パフォーマンスを改善したフィルタリング処理
 */
function filterItems(items: Item[]): Item[] {}

/**
 * 従来よりも効率的なキャッシュ機能を提供します
 */
class CacheManager {}
```

**✅ 良い例**:
```typescript
/**
 * O(n log n)の計算量でアイテムをソートします
 */
function quickSort(items: Item[]): Item[] {}

/**
 * メモ化によりフィルタリング結果をキャッシュします
 */
function filterItems(items: Item[]): Item[] {}

/**
 * LRU戦略に基づくキャッシュ機能を提供します
 */
class CacheManager {}
```

**例外的に許可される場合**:

**テストコードでの閾値比較**:
```typescript
/**
 * 実行時間が1秒未満であることを検証します
 */
function testPerformance() {
  // 明確な比較基準（1秒）が存在
}

/**
 * 結果が期待値より大きいことを確認します
 */
function testThreshold(result: number, expected: number) {
  // 比較対象（expected）が明確
}
```

**コード内で比較対象が明示されている場合**:
```typescript
/**
 * bubbleSortより高速なソートを実行します
 * 
 * @param items ソート対象の配列
 * @motivation bubbleSort(O(n²))に対してO(n log n)の改善を実現
 */
function quickSort(items: Item[]): Item[] {}
```

### 要約行の品質チェック

- [ ] 関数名だけでは分からない情報を含んでいるか
- [ ] 一文で完結しているか
- [ ] IDEのポップアップで読みやすい長さか
- [ ] 核心的な機能や特徴を端的に表現しているか
- [ ] 比較表現を使う場合、比較対象が明確に特定できるか

## カスタムタグシステム

### @motivation タグ

**用途**: 設計決定・実装選択の動機を記録

**対象範囲**:
- 技術的制約による判断
- UX・感覚的考慮による決定
- 経験則・ベストプラクティスの適用
- パフォーマンス最適化の選択
- アーキテクチャパターンの採用理由

**記述例**:

```typescript
/**
 * Central event dispatcher for UI interactions.
 * 
 * @motivation 継承制約によりベースクラス直接継承が困難なため、
 *             ハンドラーパターンで複数コンポーネント間の共通ロジックを実現。
 *             また、33msスロットリングはユーザー操作感覚として自然で、
 *             システム負荷との最適バランス点として経験的に選択。
 */
class EventManager {
  // ...
}
```

```typescript
/**
 * @motivation UUIDフィルタリングは複合オブジェクトで同一エンティティが
 *             複数回検出される問題を解決。フレームワーク特有の現象で実装経験から必須と判断。
 */
private filterDuplicatesByUUID(items: ProcessableItem[]): ProcessableItem[] {
  // ...
}
```

### @scope タグ

**用途**: クラス・関数の処理対象と責任境界の明確化

**記述要素**:
- **対象**: 何を処理するか
- **対象外**: 意図的に処理しないもの
- **境界**: 処理範囲の終了条件
- **依存**: 他のモジュールとの責任分担

**記述例**:

```typescript
/**
 * Manages exclusive selection behavior for option group components.
 * 
 * @scope 
 * - 対象: SelectableItem実装オブジェクトの排他制御
 * - 対象外: 単独選択コンポーネントの状態管理、非選択系オブジェクト
 * - 境界: 同一SelectionManager登録オブジェクト間のみ
 * - 依存: 各アイテムの個別状態はItemHandlerに委譲
 */
class SelectionManager<Value> {
  // ...
}
```

```typescript
/**
 * @scope
 * - 対象: オブジェクト階層の上向きトラバーサル
 * - 対象外: 子オブジェクトの検索、ルート外オブジェクト
 * - 境界: parent === null時点で検索終了
 * - 依存: IInteractable判定は各オブジェクトの実装に依存
 */
private findTargetInHierarchy(obj: HierarchyNode): InteractionHandler<unknown> | null {
  // ...
}
```

## @description の契約重視アプローチ

### 基本原則：実装ではなく契約を記述

**@descriptionの目的**: コードの内部動作ではなく、外部に対する約束・契約を明示

**記述すべき内容**:
- **戻り値の保証**: 何を返すか、どのような状態で返すか
- **副作用の明示**: 何を変更するか/変更しないか
- **エラー条件**: いつ例外が発生するか、どのような例外か
- **境界条件**: 特殊な入力（null、空配列等）への対応
- **無視条件**: 何を処理しない、どのような場合にスキップするか

### 良い例 vs 悪い例

**❌ 悪い例（実装解説）**:
```typescript
/**
 * @description forループでitemsを走査し、validateメソッドを呼び出して
 *              条件をチェックし、新しい配列にpushして返します。
 */
function filterItems(items: Item[]): Item[] {
  // 実装は読めば自明
}
```

**✅ 良い例（外部契約）**:
```typescript
/**
 * @description 有効なアイテムのみを含む新しい配列を返します。
 *              空配列が渡された場合は空配列を返します。
 *              不正なアイテムは警告なしに除外されます。
 *              元の配列は変更されません。
 */
function filterItems(items: Item[]): Item[] {
  // 実装詳細
}
```

**✅ 状態管理の契約例**:
```typescript
/**
 * @description 指定されたアイテムを選択状態に設定します。
 *              既に選択済みの場合は何も行いません。
 *              無効なアイテムが指定された場合はfalseを返します。
 *              選択状態の変更時はchangeイベントを発火します。
 */
function selectItem(item: Item): boolean {
  // 実装詳細
}
```

**✅ 非同期処理の契約例**:
```typescript
/**
 * @description データを非同期で取得し、Promiseを返します。
 *              ネットワークエラーの場合はリトライを3回実行します。
 *              3回失敗した場合はNetworkErrorを投げます。
 *              キャッシュが有効な場合は即座に解決されます。
 */
async function fetchData(id: string): Promise<Data> {
  // 実装詳細
}
```

### 契約記述のチェックリスト

**戻り値について**:
- [ ] 正常時に何を返すか明記されているか
- [ ] 特殊ケース（空、null等）の戻り値が説明されているか
- [ ] 戻り値の状態・形式が明確か

**副作用について**:
- [ ] 何を変更するか/しないかが明記されているか
- [ ] 外部システムへの影響が記述されているか
- [ ] イベント発火の条件が明確か

**エラー処理について**:
- [ ] どのような場合に例外が発生するか記述されているか
- [ ] 例外の種類が明記されているか
- [ ] エラー時の状態が説明されているか

## 既存タグ強化パターン

### @internal の使用基準

**基底クラス・非公開API用途**:

```typescript
/**
 * Generic base class for interactive mesh objects.
 * 
 * @internal 
 * @motivation 直接使用ではなく、ClickableMesh/CheckBoxMesh/RadioButtonMeshの
 *             基底として共通機能を提供。型安全性確保のため非エクスポート。
 */
class InteractiveMesh<Value, Handler extends ButtonInteractionHandler<Value>> {
  // ...
}
```

### @example の戦略的配置

**複雑な概念・エッジケースの具体例**:

```typescript
/**
 * @example
 * ```typescript
 * // 基本使用法
 * const manager = new EventManager(container, options);
 * 
 * // 多重ビューポート対応
 * const viewport = { x: 0, y: 0, width: 512, height: 512 };
 * const manager = new EventManager(container, { viewport });
 * 
 * // パフォーマンス調整
 * const manager = new EventManager(container, { 
 *   throttlingTime_ms: 16  // 60FPS対応
 * });
 * ```
 */
```

## プロジェクト特化ガイドライン

### Three.js特有パターン

**EventEmitter継承制約**:
```typescript
/**
 * @motivation EventEmitter3の型制約(primus/eventemitter3#243)により
 *             Three.jsオブジェクトの直接継承が困難。ハンドラーパターンで回避。
 */
```

**階層トラバーサル**:
```typescript
/**
 * @motivation Three.jsのparent-child関係でインタラクティブオブジェクトを
 *             子オブジェクトに配置するUI設計に対応。Sceneまで遡って検索。
 */
```

**マルチフェース問題**:
```typescript
/**
 * @motivation BoxGeometryなど複数面を持つジオメトリで同一オブジェクトが
 *             複数回ヒットする問題をUUIDで解決。Three.js特有の現象。
 */
```

### パフォーマンス決定の記録

**スロットリング値**:
```typescript
/**
 * @motivation 33ms(約30FPS)はマウス追従の自然さとCPU負荷のバランス点。
 *             16ms(60FPS)は過剰、66ms(15FPS)はユーザー体験を損なう。
 */
```

**メモリ最適化**:
```typescript
/**
 * @motivation currentOverの配列管理により、マウスアウト時の確実な状態クリアを実現。
 *             メモリリークを防ぐため、dispose()での明示的なクリーンアップが必要。
 */
```

## 実装品質基準

### @motivation記述品質

**良い例**:
- 具体的な制約・要因を明記
- 代替案を検討した痕跡
- 感覚的判断でも論理的説明を試行

**避けるべき例**:
- 「パフォーマンスのため」（具体性不足）
- 「Three.jsの制約」（詳細不明）
- 「ベストプラクティス」（根拠不明）

### @scope記述品質

**良い例**:
- 対象・対象外・境界を明確に分離
- 他のモジュールとの責任分担を明記
- エッジケースの処理方針を含む

**避けるべき例**:
- 「マウスイベントを処理」（曖昧）
- 「Three.jsオブジェクト用」（範囲不明）
- 「UIインタラクション」（抽象的）

## LLM理解性検証

### チェックリスト

**@motivation検証**:
- [ ] 実装選択の理由が推測ではなく明記されているか
- [ ] 感覚的判断にも可能な限り論理的説明があるか
- [ ] 将来の変更で参考になる情報が含まれているか

**@scope検証**:
- [ ] 処理対象・対象外が具体的に記述されているか
- [ ] 責任境界が他のモジュールとの関係で明確か
- [ ] エッジケース・例外処理の方針が含まれているか

**統合検証**:
- [ ] LLMが類似コードを書く際に十分な指針となるか
- [ ] 人間の開発者が6か月後に読んで理解できるか
- [ ] 設計意図が将来のリファクタリングで保持されるか